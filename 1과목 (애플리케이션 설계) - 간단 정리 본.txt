I. 애플리케이션 설계

1. 소프트웨어 생명 주기

- i. 폭포수 모형 - 결과 철저하게 검토하여 승인 과정 거친 후, 다음 단계로 진행
    - 1. 가장 오래되고 폭넓게 사용 -> 고전적 생명 주기 모형
    - 2. 제품의 일부가 될 메뉴얼 작성
    - 3. 두 개 이상의 과정이 병행하여 수행되지 않음

- ii. 프로토타입 모형 - 최종 결과물을 예측하는 모형 --> 시제품 미리 제작
    - 1. 사용자와 시스템 사이의 인터페이스
    - 2. 시스템 모형 만드는 과정, 요구된 소프트웨어를 구현 -> 구현 단계에서 사용될 골격 코드가 됨
    - 3. 폭포수 모형 단점 보완

- iii. 나선형 모형 - 보헴 제안, 폭포수 + 프로토타입 + 위험 분석 기능
    - 1. 여러 번의 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발 -> 점진적 모형
    - 2. 위험 관리 & 최소화
    - 3. 누락 or 추가 된 요구사항 첨가 -> 정밀 & 유지보수 과정 필요 없음

- iv. 애자일 모형 - 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복
    - 1. 고객과의 소통
    - 2. 기업 활동
    - 3. Sprint or Iteration -> 짧은 개발 주기 & 고객의 평가와 요구
    - 4. 소규모 프로젝트 & 고도로 숙련된 개발자 & 급변하는 요구사항
    - 5. 스크럼, XP, 칸반, Lean, Crystal, ASD, FDD(기능 중심 개발), DSDM, DAD


2. 소프트웨어 개발 방법론

- i. 개요
    - 1. 목적 - 소프트웨어의 생산성과 품질 향상
    - 2. 개요 - 각종 기법 & 도구 체계적으로 정리하여 표준화

- ii. 구조적 방법론
    - 1. 정형화된 분석 절차 & 문서화 -> 구조적 방법론
    - 2. 분할과 정복 원리 적용

- iii. 정보공학 방법론
    - 1. 자료 중심 방법론 -> 정보 공학 방법론
    - 2. 대규모 정보 시스템 구축

- iv. 객체지향 방법론
    - 1. 현실 세계의 Entity (개체) 를 하나의 Object (객체) 로 제작 -> 객체지향 방법론
    - 2. Object, Class, Message
    - 3. 캡슐화, 정보 은닉, 추상화, 상속성, 다형성

- v. 컴포넌트 기반
    - 1. 컴포넌트 조합
    - 2. 컴포넌트 재사용
    - 3. 유지 보수 최소화
    - 4. 생산성 & 품질 향상

- vi. 애자일 방법론
    - 1. 소규모 프로젝트
    - 2. 일정한 반복 주기

- vi. 제품 계열 방법론
    - 1. 공통 기능 정의하여 개발 -> 제품 계열 방법론
    - 2. 임베디드 소프트웨어
    - 3. 영역 공학 -> 영역 분석, 영역 설계, 핵심 자산
    - 4. 응용 공학 -> 제품 요구 분석, 제품 설계, 제품 구현

3. Sprint (스프린트)

- i. 개요
    - 1. 제품 책임자 (PO) - 이해 관계자 -> 개발 의뢰자 or 사용자 -> BackLog 작성
    - 2. 스크럼 마스터 -> 조언자, 스크럼 회의 주관
    - 3. 개발팀 ->  개발자 & 디자이너 & 테스터 -- 7 ~ 8명

- ii. 개발 프로세스
    - 1. 제품 백로그
    - 2. Sprint 계획 회의
    - 3. Sprint
    - 4. 일일 스크럼 회의
    - 5. Sprint 검토 회의
    - 6. Sprint 회고

4. XP (eXtreme Programming)

- i. 개요
    - 1. 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여
    - 2. Release 기간 짧게 반복 -> 고객 요구사항 반영에 대한 가시성 증대

- ii. 핵심 가치
    - 1. 의사소통
    - 2. 단순성
    - 3. 용기
    - 4. 존중
    - 5. 피드백

- iii. XP 개발 프로세스
    - 1. 사용자 스토리
    - 2. 릴리즈 계획 수립
    - 3. 스파이크
    - 4. 이터레이션
    - 5. 승인 검사
    - 6. 소규모 릴리즈

- iv. XP 주요 실천 방법
    - 1. Pair Programming -> 개발에 대한 공동 책임
    - 2. Collective Ownership (공동 코드 소유) -> 권한과 책임 공동 소유
    - 3. Test-Driven Development (테스트 주도 개발) -> 테스트 케이스 작성 & 자동화된 테스팅 도구
    - 4. Whole Team -> 각자 자신의 역할 & 역할에 대한 책임
    - 5. Continuous Integration -> 모듈 단위
    - 6. Design Improvement -> 유연성 강화 -> 시스템 재구성
    - 7. Small Release -> Release 기간 짧게 반복

II. 요구사항 정의

1. 요구사항 유형

- i. 기능 요구 사항
    - 1. 시스템 사항
    - 2. 시스템의 저장 방식 및 연산 수행 방식
    - 3. 시스템 필수 수행 기능
    - 4. 시스템을 통해 제공받기 원하는 기능

- ii. 비기능 요구 사항
    - 1. 시스템 장비 구성 -> 하드웨어, 소프트웨어, 네트워크
    - 2. 성능
    - 3. 인터페이스
    - 4. 데이터
    - 5. 테스트
    - 6. 보안
    - 7. 품질 -> 가용성, 정합성, 상호 보완성, 대응성, 신뢰성, 사용성, 유지 & 관리성, 이식성, 확장성, 보안성
    - 8. 제약사항
    - 9. 프로젝트 관리
    - 10. 프로젝트 지원

- iii. 사용자 요구 사항
    - 1. 사용자 관점 & 시스템이 제공해야 할 요구사항
    - 2. 사용자를 위한 친숙한 표현

- iv. 시스템 요구 사항
    - 1. 개발자 관점 & 시스템 전체가 다른 시스템에 제공해야 할 요구사항
    - 2. 전문적 & 기술적인 용어
    - 3. 소프트웨어 요구사항

2. 요구사항 명세서 / 요구사항 명세 기법

- i. 요구사항 명세서
    - 1. 성능, 보안, 사용성 기술
    - 2. 프로젝트 유형
    - 3. 개별 요구사항 명세서 작성

- ii. 요구사항 명세 기법
    - 1. 정형 명세 기법 - 수학적 원리 & 모델 --> 완전선 검증 --> VDM, Z, Petri-net, CSP
    - 2. 비정형 명세 기법 - 상태 & 기능 & 객체 --> 자연어 사용 --> FSM, Decision Table, ER모델링, State Chart (SADT)


III. 요구사항 분석

1. 구조적 분석 기법
 
- i. 정의
    - 1. 자료의 흐름과 처리
    - 2. 하향식 방법 -> 시스템 세분화 & 분석 중복 배제
    - 3. 시스템 분석의 질 향상

- ii. 종류
    - 1. 자료 흐름도 (DFD)
    - 2. 자료 사전 (DD)
    - 3. 소단위 명세서 (Mini-Spec.)
    - 4. 개체 관계도 (ERD)
    - 5. 상태 전이도 (STD)
    - 6. 제어 명세서

2. 자료 흐름도 (DFD)

- i. 정의
    - 1. 자료의 흐름 및 변환 과정과 기능
    - 2. 도형 중심 기술 -> 자료 흐름도
    - 3. 자료 흐름 그래프, 버블 차트

- ii. 기능
    - 1. 프로세스 (Process) - 원 또는 둥근 사각형 => 자료 변환
    - 2. 자료 흐름 (Data Flow) - 화살표 위 자료 이름 => 자료 이동 OR 연관관계
    - 3. 자료 저장소 (Data Store) - 좌우측, 또는 우측 테두리가 없는 도형 => 파일, 데이터베이스
    - 4. 단말 (Terminator) - 사각형 => 외부 통신 & 입출력 데이터

3. 자료 사전 (DD)

- i. 정의
    - 1. 자료 흐름도 자료를 더 자세히 정의 및 기록
    - 2. 데이터를 설명하는 데이터 -> Data 의 Data OR Meta-Data

- ii. 표기 방식
    - 1. 정의 - =
    - 2. 연결 - +
    - 3. 생략 - ( )
    - 4. 선택 - { }
    - 5. 설명 - * *

4. 소단위 명세서 (Mini-Spec.)

- i. 정의
    - 1. 최하위 처리 절차
    - 2. 프로세스 명세서

- ii. Detail
    - 1. 자료 흐름도 지원
    - 2. 미리 판단하는 내용 X
    - 3. 구조적 언어, 의사 결정표 (판단표), 의사 결정도

5. 개체 관계도 (ERD) 

- i. 정의
    - 1. 자료 & 개체의 구성과 속성 & 개체 간 관계
    - 2. 개체 모델화

- ii. 종류
    - 1. 개체 - 여러 종류의 정보 (소프트웨어) -> 사각형
    - 2. 관계 - 개체 간 존재하는 상호 작용 -> 마름모
    - 3. 속성 - 개체에 관련된 특성 -> 원

6. 상태 전이도 (STD)

- i. 정의
    - 1. 시스템 상태와 상태의 변화 모델링 -> 상태 전이도
    - 2. 시스템 행위 정의

- ii. Detail
    - 1. 시스템 상태 - 직사각형
    - 2. 상태의 변화 - 화살표
    - 3. 상태 변화 조건 - 시스템 행동 제시
    - 4. 화살표 시작 - 상태 변화 시작
    - 5. 화살표 끝 - 사건의 결과로 발생하는 내용


IV. 객체지향 분석 및 설계

1. 객체 지향 분석 개념

- i. 정의
    - 1. 사용자의 요구사항 분석
    - 2. 요구된 문제와 관련된 모든 클래스(객체), 속성 & 연산, 관계 등을 정의
    - 3. 모델링

- ii. 목적
    - 1. 객체는 클래스로부터 인스턴스화 - 클래스를 식별하는 것 -> 객체지향 분석 목적
    - 2. 모델링 구성 요소 문제 모형화

2. 객체지향 분석 방법론

- i. 종류
    - 1. Rumbaugh (럼바우) - 객체 모델, 동적 모델, 기능 모델
    - 2. Booch (부치) - 미시적(Micro) 개발 프로세스 & 거시적(Macro) 개발 프로세스
    - 3. Jacobson - Use Case 강조
    - 4. Coad & Yourdon - ER Diagram 사용 -> 객체 행위 모델링
    - 5. Wirfs-Brock - 고객 명세서 평가 -> 설계 작업까지 연속적으로 수행

- ii. Rumbaugh (럼바우)
    - 1. 분석 활동 -> 객체 - 동적 - 기능
    - 2. 객체 모델링 - 정보 모델링, 객체 다이어그램
    - 3. 동적 모델링 - 상태 다이어 그램, 시간의 흐름
    - 4. 기능 모델링 - 자료 흐름도, 자료 흐름

3. 객체지향 설계 원칙

- i. 정의
    - 1. SOLID
    - 2. 시스템 변경 or 확장에 유연한 시스템 설계

- ii. 종류
    - 1. 단일 책임 원칙 (SRP) - 객체는 단 하나의 책임 & 응집도 높고, 결합도는 낮게
    - 2. 개방-폐쇄 원칙 (OCP) - 기능 추가 (기존 코드 변경 X) & 공통 인터페이스를 하나로
    - 3. 리스코프 치환 원칙 (LSP) - 자식 클래스와 부모 클래스
    - 4. 인터페이스 분리 원칙 (ISP) - 필요 없는 의존관계 X & 인터페이스가 갖는 하나의 책임
    - 5. 의존 역전 원칙 (DIP) - 추상성 높은 클래스


V. 디자인 패턴

1. 디자인 패턴 개요

- i. 정의
    - 1. 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스 -> 참고
    - 2. 세부적인 구현 방안 설계 시 참조 -> 디자인 패턴

- ii. GoF (Gang of Four - 네 명의 갱단 멤버)
    - 1. 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴 -> GoF
    - 2. 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 = 총 23개의 패턴

2. 디자인 패턴 장단점

- i. 장점
    - 1. 범용적인 코딩 스타일 -> 구조 파일 용이
    - 2. 객체지향 설계 및 구현의 생산성 증대
    - 3. 개발 시간과 비용 절약 (검증된 구조 재사용)
    - 4. 개발자 간 원활한 의사소통
    - 5. 설계 변경 요청 - 유연한 대처

- ii. 단점
    - 1. 초기 투자 비용 부담
    - 2. 객체 지향 설계 O <-> 다른 기반 애플리케이션 개발 X

3. 생성 패턴

- i. 정의
    - 1. 객체 생성과 관련된 패턴 - 총 5개
    - 2. 객체 생성 & 참조 과정 캡슐화 - 프로그램 유연성

- ii. 종류
    - 1. 추상 팩토리 - 연관 서브 클래스 한 번에 교체 -> 인터페이스 추상적 표현 (연관, 의존하는 객체들의 그룹)
    - 2. 빌더 - Instance (객체 생성) -> 객체 생성 과정 및 표현 방법 분리
    - 3. Factory Method - 서브 클래스 (객체 생성) & 상위 클래스 (인터페이스) -> 가상 생성자
    - 4. Prototype - 원본 객체 복제 (객체 생성) -> 비용 큰 경우, 주로 이용
    - 5. Singleton - 생성된 객체 여러 곳에서 참조 가능 & 동시에 여러 곳에서 참조 불가 -> 인스턴스 한 개

4. 구조 패턴

- i. 정의
    - 1. 클래스 객체 조합
    - 2. 더 큰 구조로 만들 수 있게 해주는 패턴 - 총 7개

- ii. 종류
    - 1. Adapter - 호환성 없는 클래스들의 인터페이스 -> 다른 클래스 이용 가능
    - 2. Bridge - 독립적 확장
    - 3. Composite - 복합 객체 단일 객체 구분 X -> 복합 객체 안에 복합 객체
    - 4. Decorator - 객체 간 결합 -> 능동적인 기능 확장 -> 다른 객체 덧붙이기
    - 5. Facade - 더 상위에 인터페이스 구성
    - 6. FlyWeight - 유사 객체 생성 -> 메모리 절약
    - 7. Proxy - 접근이 어려운 객체로 접속 -> 네트워크 연결, 메모리의 대용량 객체 접근

5. 행위 패턴

- i. 정의
    - 1. 책임 분배 방법
    - 2. 클래스 & 객체의 상호작용하는 방법 -> 총 11개

- ii. 종류
    - 1. 책임 연쇄 - 요청 처리 가능한 객체 둘 이상 존재 -> 객체의 연좌제 Chain
    - 2. Command - 객체의 형태로 캡슐화하여 재이용 & 필요한 정보 저장하거나 로그 -> 추상 클래스와 구체 클래스
    - 3. Interpreter - 언어의 문법 표현 패턴 -> SQL or 통신 프로토콜
    - 4. Iterator - 자료 구조 (접근 잦음) -> 순차적인 접근
    - 5. Mediator - 복잡한 상호작용 캡슐화 -> 객체 의존성 감소 & 결합도 감소 -> 객체 간 통제 및 지시 역할 (중재자)
    - 6. Memento - 객체 내부 상태 객체화 -> Ctrl + Z 와 같은 되돌리기 기능 개발
    - 7. Observer - 다른 객체들에게 변화된 상태 전달
    - 8. State - 객체의 상태
    - 9. Strategy - 동일한 계열의 알고리즘 -> 독립적으로 원하는 알고리즘 선택 (Client)
    - 10. Template Method - 공통된 내용 (상위 클래스), 세부 처리 (하위 클래스)
    - 11. Visitor - 처리 기능 분리

